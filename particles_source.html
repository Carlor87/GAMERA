

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Particles: source &mdash; GAMERA 0.9 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="GAMERA 0.9 documentation" href="index.html"/>
        <link rel="up" title="Particles" href="particles.html"/>
        <link rel="next" title="Particles: header" href="particles_header.html"/>
        <link rel="prev" title="Particles: public members" href="particles_members.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> GAMERA
          

          
          </a>

          
            
            
              <div class="version">
                0.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation and Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="classes.html">Class Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="radiation.html">Radiation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="particles.html">Particles</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="particles_members.html">Particles: public members</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="">Particles: source</a></li>
<li class="toctree-l3"><a class="reference internal" href="particles_header.html">Particles: header</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="utils.html">Utils</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="radiation.html">Radiation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="particles.html">Particles</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="particles_members.html">Particles: public members</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Particles: source</a></li>
<li class="toctree-l2"><a class="reference internal" href="particles_header.html">Particles: header</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">Utils</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">GAMERA</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="particles.html">Particles</a> &raquo;</li>
      
    <li>Particles: source</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/particles_source.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="particles-source">
<h1>Particles: source<a class="headerlink" href="#particles-source" title="Permalink to this headline">Â¶</a></h1>
<div class="highlight-C++"><div class="highlight"><pre><span class="cp">#include &quot;Particles.h&quot;</span>

<span class="n">Particles</span><span class="o">::</span><span class="n">Particles</span><span class="p">()</span> <span class="p">{</span>
  <span class="cm">/* Default values */</span>
  <span class="n">eElectronMax</span> <span class="o">=</span> <span class="mf">100000.</span><span class="p">;</span>
  <span class="n">SpectralIndex</span> <span class="o">=</span> <span class="mf">2.000</span><span class="p">;</span>
  <span class="n">Tmin</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span>
  <span class="n">CutOffFactor</span> <span class="o">=</span> <span class="mf">1000.</span><span class="p">;</span>
  <span class="n">TminInternal</span> <span class="o">=</span> <span class="mf">1.e-10</span><span class="p">;</span>
  <span class="n">TmaxInternal</span> <span class="o">=</span> <span class="mf">1.e100</span><span class="p">;</span>
  <span class="n">EminInternal</span> <span class="o">=</span> <span class="mf">1.e-3</span><span class="p">;</span>
  <span class="n">energyMarginFactor</span> <span class="o">=</span> <span class="mf">1.e-3</span><span class="p">;</span>
  <span class="n">energyMargin</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span>
  <span class="n">ebins</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
  <span class="n">SACELI_Told</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="n">R</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="p">;</span>
  <span class="n">V</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="p">;</span>
  <span class="n">gslmemory</span><span class="o">=</span><span class="mi">5000</span><span class="p">;</span>
  <span class="n">QUIETMODE</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">EminConstantForNormalisationOnly</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">DEBUG</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">ICLossLookup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">LumLookup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">NLookup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">eMaxLookup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">BFieldLookup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">RLookup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">VLookup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">escapeTimeLookup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">integratorTolerance</span> <span class="o">=</span> <span class="mf">5.e-2</span><span class="p">;</span>
  <span class="n">ParticleSpectrum</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="n">ParticleSpectrum</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">ICLossVector</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">LumVector</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">NVector</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">BVector</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">eMaxVector</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">escapeTimeVector</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">RVector</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">VVector</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="n">SpectralIndex2</span> <span class="o">=</span> <span class="n">eBreak</span> <span class="o">=</span> <span class="n">TminConstant</span> <span class="o">=</span> <span class="n">adLossCoeff</span> <span class="o">=</span> <span class="n">EminConstant</span> <span class="o">=</span>
      <span class="n">eMaxConstant</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="n">escapeTime</span> <span class="o">=</span> <span class="n">escapeTimeConstant</span> <span class="o">=</span> <span class="n">EnergyAxisLowerBoundary</span> <span class="o">=</span>
      <span class="n">EnergyAxisUpperBoundary</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="n">eBreakS2</span> <span class="o">=</span> <span class="n">eBreak2mS2</span> <span class="o">=</span> <span class="n">eBreakS</span> <span class="o">=</span> <span class="n">eBreak2mS</span> <span class="o">=</span> <span class="n">emin2mS2</span> <span class="o">=</span> <span class="n">emin2mS</span> <span class="o">=</span>
      <span class="n">emineBreak2mS2</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="n">eBreak2mSInd2</span> <span class="o">=</span> <span class="n">emin2mSInd2</span> <span class="o">=</span> <span class="n">emineBreak2mSInd2</span> <span class="o">=</span> <span class="n">fS</span> <span class="o">=</span> <span class="n">fS2</span> <span class="o">=</span> <span class="n">bremsl_epf</span> <span class="o">=</span>
      <span class="n">bremsl_eef</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="n">LumConstant</span> <span class="o">=</span> <span class="n">BConstant</span> <span class="o">=</span> <span class="n">NConstant</span> <span class="o">=</span> <span class="n">VConstant</span> <span class="o">=</span> <span class="n">RConstant</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="n">accIC</span> <span class="o">=</span> <span class="n">gsl_interp_accel_alloc</span><span class="p">();</span>
  <span class="n">accLum</span> <span class="o">=</span> <span class="n">gsl_interp_accel_alloc</span><span class="p">();</span>
  <span class="n">accN</span> <span class="o">=</span> <span class="n">gsl_interp_accel_alloc</span><span class="p">();</span>
  <span class="n">accBField</span> <span class="o">=</span> <span class="n">gsl_interp_accel_alloc</span><span class="p">();</span>
  <span class="n">acceMax</span> <span class="o">=</span> <span class="n">gsl_interp_accel_alloc</span><span class="p">();</span>
  <span class="n">accescapeTime</span> <span class="o">=</span> <span class="n">gsl_interp_accel_alloc</span><span class="p">();</span>
  <span class="n">accR</span> <span class="o">=</span> <span class="n">gsl_interp_accel_alloc</span><span class="p">();</span>
  <span class="n">accV</span> <span class="o">=</span> <span class="n">gsl_interp_accel_alloc</span><span class="p">();</span>
  <span class="n">accTr</span> <span class="o">=</span> <span class="n">gsl_interp_accel_alloc</span><span class="p">();</span>
  <span class="n">accTrInv</span> <span class="o">=</span> <span class="n">gsl_interp_accel_alloc</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">Particles</span><span class="o">::~</span><span class="n">Particles</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
  <span class="n">grid</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*   ----    END OF BINARY SEARCHES     ----   */</span>

<span class="cm">/** Speed Hack: calculate some constant that are repeatedly needed in nested</span>
<span class="cm"> * loops</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">CalculateConstants</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">emin</span> <span class="o">=</span> <span class="n">Emin</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">Kep</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Type</span><span class="p">)</span> <span class="o">||</span> <span class="n">Type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">emin</span> <span class="o">=</span> <span class="n">m_p</span><span class="p">;</span>  <span class="c1">// norm for protons or for electrons if defined per e/p</span>
                 <span class="c1">// fraction</span>
  <span class="n">eBreakS2</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">eBreak</span><span class="p">,</span> <span class="n">SpectralIndex2</span><span class="p">);</span>
  <span class="n">eBreak2mS2</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">eBreak</span><span class="p">,</span> <span class="mf">2.</span> <span class="o">-</span> <span class="n">SpectralIndex2</span><span class="p">);</span>
  <span class="n">eBreak2mSInd2</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">eBreak</span><span class="p">);</span>
  <span class="n">eBreakS</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">eBreak</span><span class="p">,</span> <span class="n">SpectralIndex</span><span class="p">);</span>
  <span class="n">eBreak2mS</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">eBreak</span><span class="p">,</span> <span class="mf">2.</span> <span class="o">-</span> <span class="n">SpectralIndex</span><span class="p">);</span>
  <span class="n">emin2mS2</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">emin</span><span class="p">,</span> <span class="mf">2.</span> <span class="o">-</span> <span class="n">SpectralIndex2</span><span class="p">);</span>
  <span class="n">emin2mS</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">emin</span><span class="p">,</span> <span class="mf">2.</span> <span class="o">-</span> <span class="n">SpectralIndex</span><span class="p">);</span>
  <span class="n">emin2mSInd2</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">emin</span><span class="p">);</span>
  <span class="n">emineBreak2mS2</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">emin</span> <span class="o">/</span> <span class="n">eBreak</span><span class="p">,</span> <span class="mf">2.</span> <span class="o">-</span> <span class="n">SpectralIndex2</span><span class="p">);</span>
  <span class="n">emineBreak2mSInd2</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">emin</span> <span class="o">/</span> <span class="n">eBreak</span><span class="p">);</span>
  <span class="n">fS</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">-</span> <span class="n">SpectralIndex</span><span class="p">);</span>
  <span class="n">fS2</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">-</span> <span class="n">SpectralIndex2</span><span class="p">);</span>
  <span class="n">bremsl_epf</span> <span class="o">=</span> <span class="mf">3.</span> <span class="o">*</span> <span class="n">fineStructConst</span> <span class="o">*</span> <span class="n">sigma_T</span> <span class="o">*</span> <span class="n">c_speed</span> <span class="o">*</span> <span class="n">m_e</span> <span class="o">/</span> <span class="n">pi</span><span class="p">;</span>
  <span class="n">bremsl_eef</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.</span> <span class="o">*</span> <span class="n">fineStructConst</span> <span class="o">*</span> <span class="n">sigma_T</span> <span class="o">*</span> <span class="n">c_speed</span> <span class="o">*</span> <span class="n">m_e</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">pi</span><span class="p">));</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** fill the lookup holding the particle spectrum {E(erg) - N(erg^-1) */</span>
<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">CalculateParticleSpectrum</span><span class="p">(</span><span class="n">string</span> <span class="n">type</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">onlyprepare</span><span class="p">,</span>
                                          <span class="kt">bool</span> <span class="n">dontinitialise</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="s">&quot;electrons&quot;</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="s">&quot;protons&quot;</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Particles::FillParticleSpectrumLookup: What the fuck! Specify &quot;</span>
            <span class="s">&quot;supported particle species! &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">QUIETMODE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;___________________________________&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&gt;&gt; STARTING NEW PARTICLE EVOLUTION &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;   (-&gt; electrons)     &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;   (-&gt; protons)     &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/* reset Particle Lookup */</span>
  <span class="n">Clear2DVector</span><span class="p">(</span><span class="n">ParticleSpectrum</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">Emin</span> <span class="o">=</span> <span class="n">m_p</span><span class="p">;</span>  <span class="c1">// norm for protons or for electrons if defined per e/p</span>
                 <span class="c1">// fraction</span>
  <span class="k">else</span>
    <span class="n">Emin</span> <span class="o">=</span> <span class="n">m_e</span><span class="p">;</span>
  <span class="cm">/* if lower energy bound is externally set</span>
<span class="cm">   * use this value for the normalisation of the spectrum</span>
<span class="cm">   */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">EminConstant</span><span class="o">&gt;</span><span class="n">m_e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Emin</span> <span class="o">=</span> <span class="n">EminConstant</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">EminConstant</span><span class="o">&gt;</span><span class="n">EminInternal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">EminInternal</span> <span class="o">=</span> <span class="mf">1.1</span><span class="o">*</span><span class="n">EminConstant</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">CalculateConstants</span><span class="p">();</span>
  <span class="n">DetermineLookupTimeBoundaries</span><span class="p">();</span>
  <span class="cm">/* determine time from where to start the iteration. Particles that would have</span>
<span class="cm">   * been injected before that time are injected as a blob at Tmin. This can</span>
<span class="cm">   * lead to bumps at low energies, depending on cooling.</span>
<span class="cm">   */</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">TminConstant</span><span class="p">)</span>
    <span class="n">Tmin</span> <span class="o">=</span> <span class="n">TminConstant</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">Tmin</span> <span class="o">=</span> <span class="mf">1.e-3</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="nf">DetermineTMin</span><span class="p">(</span><span class="n">EminInternal</span><span class="p">,</span> <span class="n">Tmin</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">Tmin</span><span class="o">&lt;</span><span class="n">TminInternal</span><span class="p">)</span> <span class="n">Tmin</span><span class="o">=</span><span class="n">TminInternal</span><span class="p">;</span>
  <span class="cm">/* get the upper energy boundary of the spectrum. This can either be</span>
<span class="cm">   * externally</span>
<span class="cm">   * set (if) or dynamically determined by the code (else).</span>
<span class="cm">   */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">eMaxConstant</span><span class="p">)</span>
    <span class="n">eMax</span> <span class="o">=</span> <span class="n">eMaxConstant</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">eMax</span> <span class="o">=</span> <span class="n">DetermineEmax</span><span class="p">(</span><span class="n">Tmin</span><span class="p">);</span>

  <span class="cm">/* apply a safe margin to the upper energy boundary</span>
<span class="cm">   * in order to prevent numerical effects at the upper end of the spectrum.</span>
<span class="cm">   */</span>
  <span class="n">energyMargin</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="o">-</span><span class="n">log</span><span class="p">(</span><span class="n">energyMarginFactor</span><span class="p">),</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">CutOffFactor</span><span class="p">);</span>
  <span class="n">eMax</span> <span class="o">*=</span> <span class="n">energyMargin</span><span class="p">;</span>

  <span class="cm">/* if emax falls below emin, return dummy vector with zeroes */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">eMax</span> <span class="o">&lt;=</span> <span class="n">Emin</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Particles::FillParticleSpectrumLookup Whaat? eMax lower than &quot;</span>
            <span class="s">&quot;Emin: eMax = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">eMax</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; Emin = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Emin</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">BVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">NVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">RVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">VVector</span><span class="p">.</span><span class="n">size</span><span class="p">()))</span> <span class="p">{</span>
    <span class="cm">/* call numerical solver. */</span>
    <span class="n">PrepareAndRunNumericalSolver</span><span class="p">(</span><span class="n">ParticleSpectrum</span><span class="p">,</span> <span class="n">onlyprepare</span><span class="p">,</span> <span class="n">dontinitialise</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Type</span><span class="o">==</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">BConstant</span> <span class="o">||</span> <span class="n">NConstant</span> <span class="o">||</span> <span class="n">VConstant</span><span class="p">))</span> <span class="p">{</span>
    <span class="cm">/* if B-Field, ambient density and speed are set externally thus constant.</span>
<span class="cm">     * This means constant energy losses due to Brems- and Synchrotronstrahlung</span>
<span class="cm">     * as well as adiabatic expansion (currently IC losses are always constant</span>
<span class="cm">     * in GAMERA.).</span>
<span class="cm">     */</span>
    <span class="n">CalculateEnergyTrajectory</span><span class="p">();</span>
    <span class="n">CalcSpecSemiAnalyticConstELoss</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Type</span><span class="o">==</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">VConstant</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* if B-Field, ambient density and speed are set externally thus constant.</span>
<span class="cm">     * This means constant energy losses due to Brems- and Synchrotronstrahlung</span>
<span class="cm">     * as well as adiabatic expansion (currently IC losses are always constant</span>
<span class="cm">     * in GAMERA.).</span>
<span class="cm">     */</span>
    <span class="n">CalculateEnergyTrajectory</span><span class="p">();</span>
    <span class="n">CalcSpecSemiAnalyticConstELoss</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">CalcSpecSemiAnalyticNoELoss</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">QUIETMODE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&gt;&gt; PARTICLE EVOLUTION DONE. EXITING.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** particle injection spectrum, assuming a power-law+super exponential Cut-off</span>
<span class="cm"> * supported injection Spectra:</span>
<span class="cm"> * - Power Law with exponential cut-off (pars: SpectralIndex,eMax - cut energy,</span>
<span class="cm"> * CutOffFactor - ~exp[-(e/emax)^cutOffFactorInternal])</span>
<span class="cm"> * - Broken power law with exponential cut-off (pars: SpectralIndex,eMax - cut</span>
<span class="cm"> * energy, eBreak - break energy, CutOffFactor -</span>
<span class="cm"> * ~exp[-(e/emax)^cutOffFactorInternal])</span>
<span class="cm"> * - exponential cut-offs can be mitigated by very high values of &quot;CutOffFactor&quot;</span>
<span class="cm"> */</span>
<span class="kt">double</span> <span class="n">Particles</span><span class="o">::</span><span class="n">SourceSpectrum</span><span class="p">(</span><span class="kt">double</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">PowerLawInjectionSpectrum</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">eMax</span><span class="p">,</span> <span class="mf">10.</span> <span class="o">*</span> <span class="n">eMax</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="n">Particles</span><span class="o">::</span><span class="n">PowerLawInjectionSpectrum</span><span class="p">(</span><span class="kt">double</span> <span class="n">e</span><span class="p">,</span> <span class="kt">double</span> <span class="n">ecut</span><span class="p">,</span>
                                            <span class="kt">double</span> <span class="n">emax</span><span class="p">)</span> <span class="p">{</span>

  <span class="cm">/* exponential cut factor */</span>
  <span class="kt">double</span> <span class="n">cutOffFactorInternal</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">pow</span><span class="p">(</span><span class="n">e</span> <span class="o">/</span> <span class="n">ecut</span><span class="p">,</span> <span class="n">CutOffFactor</span><span class="p">));</span>
  <span class="cm">/* calculate norm */</span>
  <span class="kt">double</span> <span class="n">integral</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="cm">/* Broken power-law. Used, if both SpectralIndex2 and a break energy are</span>
<span class="cm">   * specified */</span>
  <span class="c1">// FIXME: special case SpectralIndex,SpectralIndex2 = 2</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">SpectralIndex2</span> <span class="o">&amp;&amp;</span> <span class="n">eBreak</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">SpectralIndex</span> <span class="o">!=</span> <span class="mf">2.</span> <span class="o">&amp;&amp;</span> <span class="n">SpectralIndex2</span> <span class="o">!=</span> <span class="mf">2.</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">integral</span> <span class="o">=</span> <span class="n">eBreakS2</span> <span class="o">*</span> <span class="p">(</span><span class="n">eBreak2mS2</span> <span class="o">-</span> <span class="n">emin2mS2</span><span class="p">)</span> <span class="o">*</span> <span class="n">fS2</span><span class="p">;</span>
      <span class="n">integral</span> <span class="o">+=</span> <span class="n">eBreakS</span> <span class="o">*</span> <span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">emax</span><span class="p">,</span> <span class="mf">2.</span> <span class="o">-</span> <span class="n">SpectralIndex</span><span class="p">)</span> <span class="o">-</span> <span class="n">eBreak2mS</span><span class="p">)</span> <span class="o">*</span> <span class="n">fS</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">emax</span> <span class="o">&lt;=</span> <span class="n">eBreak</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">integral</span> <span class="o">=</span>
            <span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">emax</span> <span class="o">/</span> <span class="n">eBreak</span><span class="p">,</span> <span class="mf">2.</span> <span class="o">-</span> <span class="n">SpectralIndex2</span><span class="p">)</span> <span class="o">-</span> <span class="n">emineBreak2mS2</span><span class="p">)</span> <span class="o">*</span> <span class="n">fS2</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Particles::PowerLawInjectionSpectrum: todo!&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="cm">/* else, a single power-law is used in the integrated flux (introduces a small</span>
<span class="cm">   * error if</span>
<span class="cm">   * depending on &quot;CutOffFactor&quot;:</span>
<span class="cm">   */</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">SpectralIndex</span> <span class="o">!=</span> <span class="mf">2.</span><span class="p">)</span>
      <span class="n">integral</span> <span class="o">=</span> <span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">emax</span><span class="p">,</span> <span class="mf">2.</span> <span class="o">-</span> <span class="n">SpectralIndex</span><span class="p">)</span> <span class="o">-</span> <span class="n">emin2mS</span><span class="p">)</span> <span class="o">*</span>
                 <span class="n">fS</span><span class="p">;</span>  <span class="c1">// FIXME replace with errfunc for exp cutof. (minor error)</span>
    <span class="k">else</span>
      <span class="n">integral</span> <span class="o">=</span> <span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">emax</span><span class="p">)</span> <span class="o">-</span> <span class="n">emin2mSInd2</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/* calculate the normalisation */</span>
  <span class="kt">double</span> <span class="n">SourceSpectrumNorm</span> <span class="o">=</span> <span class="n">Lum</span> <span class="o">/</span> <span class="n">integral</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">J</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="cm">/* Broken power-law. If both SpectralIndex2 and a break energy was specified</span>
<span class="cm">   */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">SpectralIndex2</span> <span class="o">&amp;&amp;</span> <span class="n">eBreak</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">&gt;</span> <span class="n">eBreak</span><span class="p">)</span>
      <span class="n">J</span> <span class="o">=</span> <span class="n">SourceSpectrumNorm</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">e</span> <span class="o">/</span> <span class="n">eBreak</span><span class="p">,</span> <span class="o">-</span><span class="n">SpectralIndex</span><span class="p">)</span> <span class="o">*</span>
          <span class="n">cutOffFactorInternal</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">&lt;=</span> <span class="n">eBreak</span> <span class="o">&amp;&amp;</span> <span class="n">emax</span> <span class="o">&lt;=</span> <span class="n">eBreak</span><span class="p">)</span>
      <span class="n">J</span> <span class="o">=</span> <span class="n">SourceSpectrumNorm</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">e</span> <span class="o">/</span> <span class="n">eBreak</span><span class="p">,</span> <span class="o">-</span><span class="n">SpectralIndex2</span><span class="p">)</span> <span class="o">*</span>
          <span class="n">cutOffFactorInternal</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="n">J</span> <span class="o">=</span> <span class="n">SourceSpectrumNorm</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">e</span> <span class="o">/</span> <span class="n">eBreak</span><span class="p">,</span> <span class="o">-</span><span class="n">SpectralIndex2</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/* super-exponential cutoff as ~exp[-(e/emax)^cutOffFactorInternal] */</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">SourceSpectrumNorm</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">-</span><span class="n">SpectralIndex</span><span class="p">)</span> <span class="o">*</span> <span class="n">cutOffFactorInternal</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">DEBUG</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">J</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">J</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** Set important class members to values at time t (as specified in</span>
<span class="cm"> * CRLumLookup). */</span>
<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">SetMembers</span><span class="p">(</span><span class="kt">double</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">TminInternal</span> <span class="o">||</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">TmaxInternal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Particles::SetMembers: Time (&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;yrs vs {&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">TminInternal</span>
         <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">TmaxInternal</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;}) outside boundaries.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  -&gt; Using values from previous time step. If you don&#39;t want &quot;</span>
            <span class="s">&quot;this, you have to extend &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;     your Lookups (Luminosity,R,V,B,N etc) or set constant values &quot;</span>
            <span class="s">&quot;(via e.g. SetBField()). &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Constants</span> <span class="o">=</span> <span class="p">{</span><span class="n">LumConstant</span><span class="p">,</span>  <span class="n">NConstant</span><span class="p">,</span>         <span class="n">BConstant</span><span class="p">,</span>
               <span class="n">eMaxConstant</span><span class="p">,</span> <span class="n">escapeTimeConstant</span><span class="p">};</span>
  <span class="n">splines</span> <span class="o">=</span> <span class="p">{</span><span class="n">LumLookup</span><span class="p">,</span> <span class="n">NLookup</span><span class="p">,</span> <span class="n">BFieldLookup</span><span class="p">,</span> <span class="n">eMaxLookup</span><span class="p">,</span> <span class="n">escapeTimeLookup</span><span class="p">};</span>
  <span class="n">accs</span> <span class="o">=</span> <span class="p">{</span><span class="n">accLum</span><span class="p">,</span> <span class="n">accN</span><span class="p">,</span> <span class="n">accBField</span><span class="p">,</span> <span class="n">acceMax</span><span class="p">,</span> <span class="n">accescapeTime</span><span class="p">};</span>
  <span class="n">vals</span> <span class="o">=</span> <span class="p">{</span><span class="o">&amp;</span><span class="n">Lum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">N</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BField</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eMax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">escapeTime</span><span class="p">};</span>
  <span class="n">vs</span> <span class="o">=</span> <span class="p">{</span><span class="n">LumVector</span><span class="p">,</span> <span class="n">NVector</span><span class="p">,</span> <span class="n">BVector</span><span class="p">,</span> <span class="n">eMaxVector</span><span class="p">,</span> <span class="n">escapeTimeVector</span><span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Constants</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Constants</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="o">*</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Constants</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">splines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="o">*</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">gsl_spline_eval</span><span class="p">(</span><span class="n">splines</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">,</span> <span class="n">accs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="n">R</span> <span class="o">=</span> <span class="n">V</span> <span class="o">=</span> <span class="n">adLossCoeff</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">RConstant</span> <span class="o">&amp;&amp;</span> <span class="n">VConstant</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">VConstant</span><span class="o">*</span><span class="n">yr_to_sec</span> <span class="o">+</span> <span class="n">RConstant</span><span class="p">;</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">VConstant</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">RConstant</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">VConstant</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">RConstant</span><span class="p">;</span>
    <span class="n">V</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">yr_to_sec</span><span class="o">*</span><span class="n">V</span><span class="p">;</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">VConstant</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">RVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">RVector</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
          <span class="n">t</span> <span class="o">&lt;</span> <span class="n">RVector</span><span class="p">[</span><span class="n">RVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">gsl_spline_eval</span><span class="p">(</span><span class="n">RLookup</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">accR</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="n">VVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">VVector</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
          <span class="n">t</span> <span class="o">&lt;</span> <span class="n">VVector</span><span class="p">[</span><span class="n">VVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">gsl_spline_eval</span><span class="p">(</span><span class="n">VLookup</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">accV</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">R</span> <span class="o">&amp;&amp;</span> <span class="n">V</span><span class="p">)</span> <span class="n">adLossCoeff</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="n">R</span><span class="p">;</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">SetLookup</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">,</span> <span class="n">string</span> <span class="n">LookupType</span><span class="p">,</span>
                          <span class="kt">bool</span> <span class="n">UPDATE</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Particles::SetLookup: lookup vector empty. Exiting.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">double</span> <span class="n">x</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">y</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="n">gsl_spline</span> <span class="o">*</span><span class="n">ImportLookup</span> <span class="o">=</span> <span class="n">gsl_spline_alloc</span><span class="p">(</span><span class="n">gsl_interp_akima</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="n">gsl_spline_init</span><span class="p">(</span><span class="n">ImportLookup</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">st</span><span class="p">{</span><span class="s">&quot;ICLoss&quot;</span><span class="p">,</span> <span class="s">&quot;Luminosity&quot;</span><span class="p">,</span> <span class="s">&quot;AmbientDensity&quot;</span><span class="p">,</span> <span class="s">&quot;BField&quot;</span><span class="p">,</span>
                    <span class="s">&quot;Emax&quot;</span><span class="p">,</span>   <span class="s">&quot;EscapeTime&quot;</span><span class="p">,</span> <span class="s">&quot;Radius&quot;</span><span class="p">,</span>         <span class="s">&quot;Speed&quot;</span><span class="p">};</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">gsl_spline</span> <span class="o">**&gt;</span> <span class="n">spl</span><span class="p">{</span><span class="o">&amp;</span><span class="n">ICLossLookup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">LumLookup</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">NLookup</span><span class="p">,</span>
                            <span class="o">&amp;</span><span class="n">BFieldLookup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eMaxLookup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">escapeTimeLookup</span><span class="p">,</span>
                            <span class="o">&amp;</span><span class="n">RLookup</span><span class="p">,</span>      <span class="o">&amp;</span><span class="n">VLookup</span><span class="p">};</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">*&gt;</span> <span class="n">vs</span><span class="p">{</span>
      <span class="o">&amp;</span><span class="n">ICLossVector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">LumVector</span><span class="p">,</span>        <span class="o">&amp;</span><span class="n">NVector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BVector</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="n">eMaxVector</span><span class="p">,</span>   <span class="o">&amp;</span><span class="n">escapeTimeVector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RVector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VVector</span><span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupType</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">spl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">UPDATE</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">gsl_spline_free</span><span class="p">(</span><span class="o">*</span><span class="n">spl</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
          <span class="o">*</span><span class="n">spl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Particles::SetLookup: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
               <span class="o">&lt;&lt;</span> <span class="s">&quot; lookup already set earlier. Exiting.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
          <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="o">*</span><span class="n">spl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ImportLookup</span><span class="p">;</span>
      <span class="o">*</span><span class="n">vs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** Append CRLUMLOOKUP to CRLumLookup. Time order has to be right, so the</span>
<span class="cm"> * youngest</span>
<span class="cm"> * appended entry has to be older than the oldest already existing one.</span>
<span class="cm"> * This function is useful when iteratively determining B-Field, CR Lum, source</span>
<span class="cm"> * speed and radius etc... That is, when the particle distribution influences</span>
<span class="cm"> * shock dynamics and B-Field.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">ExtendLookup</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">,</span> <span class="n">string</span> <span class="n">LookupType</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Particles::ExtendLookup: Input vector empty. Exiting.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">st</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Luminosity&quot;</span><span class="p">,</span> <span class="s">&quot;AmbientDensity&quot;</span><span class="p">,</span> <span class="s">&quot;BField&quot;</span><span class="p">,</span> <span class="s">&quot;Emax&quot;</span><span class="p">,</span>
                       <span class="s">&quot;EscapeTime&quot;</span><span class="p">,</span> <span class="s">&quot;Radius&quot;</span><span class="p">,</span>         <span class="s">&quot;Speed&quot;</span><span class="p">};</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">vs</span> <span class="o">=</span> <span class="p">{</span><span class="n">LumVector</span><span class="p">,</span>  <span class="n">NVector</span><span class="p">,</span>          <span class="n">BVector</span><span class="p">,</span>
                                         <span class="n">eMaxVector</span><span class="p">,</span> <span class="n">escapeTimeVector</span><span class="p">,</span> <span class="n">RVector</span><span class="p">,</span>
                                         <span class="n">VVector</span><span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupType</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">vs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">vs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Particles::ExtendCRLumLookup - WTF, the vector which to add (&quot;</span>
             <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;) to the existing one starts at earlier times than &quot;</span>
                         <span class="s">&quot;the existing ones ends. Please keep time order in &quot;</span>
                         <span class="s">&quot;the vector! exiting.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">vs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">vs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
      <span class="n">SetLookup</span><span class="p">(</span><span class="n">vs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">LookupType</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** calculates the energy loss rate at a given time t from the shock dynamics,</span>
<span class="cm"> * ambient photon and B-fields.</span>
<span class="cm"> */</span>
<span class="kt">double</span> <span class="n">Particles</span><span class="o">::</span><span class="n">EnergyLossRate</span><span class="p">(</span><span class="kt">double</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">synchl</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">icl</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">adl</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">bremsl</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">bremsl_ep</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">bremsl_ee</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">gamma</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span> <span class="o">+</span> <span class="n">m_e</span><span class="p">)</span> <span class="o">/</span> <span class="n">m_e</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">)</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">gamma2</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">p</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">gamma2</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">);</span>
  <span class="cm">/* S-parameter. This is only the case in a pure hydrogen gas environment. For</span>
<span class="cm">   * more comlex mixture,</span>
<span class="cm">   * nuclear charge of the different gas species become important. See Haug2004</span>
<span class="cm">   */</span>
  <span class="kt">double</span> <span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
  <span class="cm">/* synchrotron losses */</span>
  <span class="n">synchl</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma_T</span> <span class="o">*</span> <span class="n">c_speed</span> <span class="o">*</span> <span class="n">BField</span> <span class="o">*</span> <span class="n">BField</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">/</span>
           <span class="p">(</span><span class="mf">8.</span> <span class="o">*</span> <span class="n">pi</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ICLossVector</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">icl</span><span class="o">=</span><span class="mf">0.</span><span class="p">;</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="cm">/* IC losses from the lookup table (ICLossLookup) */</span>
    <span class="n">icl</span> <span class="o">=</span> <span class="n">gsl_spline_eval</span><span class="p">(</span><span class="n">ICLossLookup</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">accIC</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/* adiabatic losses (adlossCoeff = V/R) */</span>
  <span class="n">adl</span> <span class="o">=</span> <span class="n">adLossCoeff</span> <span class="o">*</span> <span class="n">E</span><span class="p">;</span>

  <span class="cm">/* Bremsstrahlung losses Haug+2004 */</span>
  <span class="cm">/* electron-proton bremsstrahlung */</span>
  <span class="cm">/* TODO: to be super self-consistent, calculate losses in a lookup, analogue</span>
<span class="cm">   * to the IC lookup */</span>
  <span class="n">bremsl_ep</span> <span class="o">=</span> <span class="p">((</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">gamma2</span> <span class="o">/</span> <span class="mf">9.</span> <span class="o">-</span> <span class="mf">19.</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">p</span> <span class="o">/</span> <span class="mf">675.</span> <span class="o">-</span>
                <span class="mf">0.06</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">p</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">)</span> <span class="o">*</span>
                   <span class="n">p</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">p</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">)</span> <span class="o">+</span>
               <span class="n">gamma</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">gamma</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="n">p</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span> <span class="o">*</span>
              <span class="n">bremsl_epf</span> <span class="o">*</span> <span class="n">S</span> <span class="o">*</span> <span class="n">gamma2</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma2</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">p</span><span class="p">);</span>

  <span class="cm">/* electron-electron bremsstrahlung */</span>
  <span class="n">bremsl_ee</span> <span class="o">=</span>
      <span class="n">N</span> <span class="o">*</span> <span class="n">bremsl_eef</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">);</span>
  <span class="n">bremsl</span> <span class="o">=</span> <span class="n">bremsl_ep</span> <span class="o">+</span> <span class="n">bremsl_ee</span><span class="p">;</span>

  <span class="cm">/* in case of protons, only take adiabatic losses into account */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Type</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">synchl</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
    <span class="n">icl</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
    <span class="n">bremsl</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">DEBUG</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">synchl</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
    <span class="n">bremsl</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
    <span class="n">adl</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">synchl</span> <span class="o">+</span> <span class="n">icl</span> <span class="o">+</span> <span class="n">adl</span> <span class="o">+</span> <span class="n">bremsl</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** Prepare axes for the numerical solver (and if onlyprepare==false) call the</span>
<span class="cm"> * solver</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">PrepareAndRunNumericalSolver</span><span class="p">(</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">particlespectrum</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">onlyprepare</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">dontinitialise</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">EnergyAxisUpperBoundary</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">GetAxis</span><span class="p">(</span><span class="n">Emin</span><span class="p">,</span> <span class="n">EnergyAxisUpperBoundary</span><span class="p">,</span> <span class="n">ebins</span><span class="p">,</span> <span class="n">energyAxis</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">EnergyAxisLowerBoundary</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">GetAxis</span><span class="p">(</span><span class="n">EnergyAxisLowerBoundary</span><span class="p">,</span> <span class="n">eMax</span><span class="p">,</span> <span class="n">ebins</span><span class="p">,</span> <span class="n">energyAxis</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">EnergyAxisLowerBoundary</span> <span class="o">&amp;&amp;</span> <span class="n">EnergyAxisUpperBoundary</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">GetAxis</span><span class="p">(</span><span class="n">EnergyAxisLowerBoundary</span><span class="p">,</span> <span class="n">EnergyAxisUpperBoundary</span><span class="p">,</span> <span class="n">ebins</span><span class="p">,</span> <span class="n">energyAxis</span><span class="p">,</span>
            <span class="nb">true</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">GetAxis</span><span class="p">(</span><span class="n">Emin</span><span class="p">,</span> <span class="n">eMax</span><span class="p">,</span> <span class="n">ebins</span><span class="p">,</span> <span class="n">energyAxis</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">CreateGrid</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dontinitialise</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="n">SetInitialCondition</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">energyAxis</span><span class="p">,</span> <span class="n">Tmin</span><span class="p">);</span>

  <span class="cm">/* if onlyprepare=true, only the axes are initialised, but the grid is not</span>
<span class="cm">   * computed</span>
<span class="cm">   * until t=age. This is useful in conjunction with</span>
<span class="cm">   * ComputeGridInTimeInterval().</span>
<span class="cm">   */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">onlyprepare</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="n">ComputeGrid</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">energyAxis</span><span class="p">,</span> <span class="n">Tmin</span><span class="p">,</span> <span class="n">Age</span><span class="p">,</span> <span class="n">timeAxis</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** create an axis that attributes each bin with a real value. */</span>
<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">GetAxis</span><span class="p">(</span><span class="kt">double</span> <span class="n">min</span><span class="p">,</span> <span class="kt">double</span> <span class="n">max</span><span class="p">,</span> <span class="kt">int</span> <span class="n">steps</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Axis</span><span class="p">,</span>
                        <span class="kt">bool</span> <span class="n">logarithmic</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Axis</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">steps</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">logarithmic</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">min</span> <span class="o">=</span> <span class="n">log10</span><span class="p">(</span><span class="n">min</span><span class="p">);</span>
    <span class="n">max</span> <span class="o">=</span> <span class="n">log10</span><span class="p">(</span><span class="n">max</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kt">double</span> <span class="n">binsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">max</span> <span class="o">-</span> <span class="n">min</span><span class="p">)</span> <span class="o">/</span> <span class="n">steps</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Axis</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Axis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">binsize</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** create the propagation grid out of 2 1D-vectors</span>
<span class="cm"> * energy in x-direction, time in y-direction</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">CreateGrid</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Clear2DVector</span><span class="p">(</span><span class="n">grid</span><span class="p">);</span>
  <span class="n">grid</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ebins</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">grid</span><span class="p">[</span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mf">0.</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** determine the minimum time from where to start</span>
<span class="cm"> * the calculation. Electrons before that time are injected as</span>
<span class="cm"> * a single &#39;blob&#39;. This time is derived from the requirement</span>
<span class="cm"> * that the blob has slid down to energies e.g. E&lt;1GeV(EMIN) at t=Age.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">DetermineTMin</span><span class="p">(</span><span class="kt">double</span> <span class="n">emin</span><span class="p">,</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">tmin</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">logt</span><span class="p">,</span> <span class="n">logtmin</span><span class="p">,</span> <span class="n">logtmax</span><span class="p">,</span> <span class="n">logdt</span><span class="p">,</span> <span class="n">logsteps</span><span class="p">,</span> <span class="n">TMIN</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">TminInternal</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">)</span>
    <span class="n">logtmin</span> <span class="o">=</span> <span class="n">log10</span><span class="p">(</span><span class="n">TminInternal</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">logtmin</span> <span class="o">=</span> <span class="n">log10</span><span class="p">(</span><span class="n">Age</span><span class="p">)</span> <span class="o">-</span> <span class="mf">5.</span><span class="p">;</span>
  <span class="n">TMIN</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="n">logtmax</span> <span class="o">=</span> <span class="n">log10</span><span class="p">(</span><span class="n">Age</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">logtmin</span> <span class="o">&gt;</span> <span class="n">logtmax</span><span class="p">)</span> <span class="n">logtmin</span> <span class="o">=</span> <span class="n">logtmax</span> <span class="o">-</span> <span class="mf">3.</span><span class="p">;</span>
  <span class="n">logsteps</span> <span class="o">=</span> <span class="mf">30.</span><span class="p">;</span>
  <span class="n">logdt</span> <span class="o">=</span> <span class="p">(</span><span class="n">logtmax</span> <span class="o">-</span> <span class="n">logtmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">logsteps</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">logt</span> <span class="o">=</span> <span class="n">logtmin</span><span class="p">;</span> <span class="n">logt</span> <span class="o">&lt;</span> <span class="n">logtmax</span><span class="p">;</span> <span class="n">logt</span> <span class="o">+=</span> <span class="n">logdt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">CalculateEnergyTrajectory</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">logt</span><span class="p">));</span>
    <span class="n">gsl_interp_accel_reset</span><span class="p">(</span><span class="n">accTrInv</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gsl_spline_eval_e</span><span class="p">(</span><span class="n">energyTrajectoryInverse</span><span class="p">,</span> <span class="n">log10</span><span class="p">(</span><span class="n">emin</span><span class="p">),</span> <span class="n">accTrInv</span><span class="p">,</span>
                          <span class="o">&amp;</span><span class="n">TMIN</span><span class="p">))</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="n">TMIN</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">TMIN</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TMIN</span> <span class="o">&gt;</span> <span class="n">Age</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">tmin</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">logt</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** Determine the maximum energy of particles between tmin and Age.</span>
<span class="cm"> * This energy is then used as upper boundary for the energy dimension of the</span>
<span class="cm"> * grid.</span>
<span class="cm"> */</span>
<span class="kt">double</span> <span class="n">Particles</span><span class="o">::</span><span class="n">DetermineEmax</span><span class="p">(</span><span class="kt">double</span> <span class="n">tmin</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">t</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">tt</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">eMaxHistory</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="p">;</span>
  <span class="n">t</span> <span class="o">=</span> <span class="n">tmin</span><span class="p">;</span>
  <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">Age</span> <span class="o">-</span> <span class="n">tmin</span><span class="p">)</span> <span class="o">/</span> <span class="mf">10000.</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="n">Age</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gsl_spline_eval_e</span><span class="p">(</span><span class="n">eMaxLookup</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">acceMax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tt</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tt</span> <span class="o">&gt;</span> <span class="n">eMaxHistory</span><span class="p">)</span> <span class="n">eMaxHistory</span> <span class="o">=</span> <span class="n">tt</span><span class="p">;</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">eMaxHistory</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** set initial condition (a.k.a. set the first energy vector at t=tmin of the</span>
<span class="cm"> * grid) */</span>
<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">SetInitialCondition</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Grid</span><span class="p">,</span>
                                    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">EnergyAxis</span><span class="p">,</span>
                                    <span class="kt">double</span> <span class="n">startTime</span><span class="p">)</span> <span class="p">{</span>

  <span class="kt">double</span> <span class="n">t0</span> <span class="o">=</span> <span class="n">startTime</span><span class="p">;</span>
  <span class="n">SetMembers</span><span class="p">(</span><span class="n">t0</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EnergyAxis</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">e</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">EnergyAxis</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">pow</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">EnergyAxis</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]));</span>
    <span class="n">Grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t0</span> <span class="o">*</span> <span class="n">yr_to_sec</span> <span class="o">*</span> <span class="n">SourceSpectrum</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">* Center piece of the class: Numerical solver of the particle spectrum.</span>
<span class="cm">* It treats cooling as an advective flow in energy space, and uses a piece-wise</span>
<span class="cm">* linear numerical scheme to transport particles from one energy bin in the</span>
<span class="cm">* next,</span>
<span class="cm">* where the (energy-dependent) cooling rate is treated as the flow velocity of</span>
<span class="cm">* the &#39;fluid&#39;. To realise sharp edges in the resulting spectra, the &#39;SuperBee&#39;</span>
<span class="cm">* and &#39;MinMod&#39; slope</span>
<span class="cm">* limiters are available (default: MinMod). This slows down the procedure, and</span>
<span class="cm">* can manually be</span>
<span class="cm">* disabled.</span>
<span class="cm">* TODO: write option to choose between slope limiter methods / disable them</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">ComputeGrid</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Grid</span><span class="p">,</span>
                            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">EnergyAxis</span><span class="p">,</span> <span class="kt">double</span> <span class="n">startTime</span><span class="p">,</span>
                            <span class="kt">double</span> <span class="n">Age</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">TimeAxis</span><span class="p">,</span>
                            <span class="kt">double</span> <span class="n">minTimeBin</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">TimeAxis</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">startTime</span><span class="p">);</span>
  <span class="n">TimeAxis</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">0.</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">value</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">quot</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">t</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">e1</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">e2</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">ebin</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">tbin</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">deltaE1</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">deltaE2</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">ElossRate_e1</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">ElossRate_e2</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Esize</span> <span class="o">=</span> <span class="n">EnergyAxis</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">tt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">largestFilledBin</span> <span class="o">=</span> <span class="n">Esize</span><span class="p">;</span>
  <span class="kt">long</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="cm">/* append a new energy vector that will always hold the energy spectrum at the</span>
<span class="cm">   *  next time step and initialise it with zeroes.</span>
<span class="cm">   */</span>
  <span class="n">Grid</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EnergyAxis</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Grid</span><span class="p">[</span><span class="n">Grid</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mf">0.</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/* info writeout. Disable it by using &#39;ToggleQuietMode()&#39; */</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Type</span> <span class="o">&amp;&amp;</span> <span class="n">QUIETMODE</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;** Evolving Electron Spectrum:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Type</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">QUIETMODE</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;** Evolving Proton Spectrum:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="cm">/* main loop over time  */</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">double</span> <span class="n">T</span> <span class="o">=</span> <span class="n">startTime</span><span class="p">;</span> <span class="n">T</span> <span class="o">&lt;</span> <span class="n">Age</span><span class="p">;</span> <span class="n">T</span> <span class="o">+=</span> <span class="n">tbin</span> <span class="o">/</span> <span class="n">yr_to_sec</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Set Members (CR luminosity, B-field etc.) at time T */</span>
    <span class="n">SetMembers</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
    <span class="cm">/* dynamically determine tbin size. This is a critical step</span>
<span class="cm">     * for the speed of the algorithm. Since the time step size is</span>
<span class="cm">     * proportional to Ebinsize(eMax)/Edot(eMax) and Edot ~ E^2,</span>
<span class="cm">     * eMax - or the largest relevant energy bin - should be chosen</span>
<span class="cm">     * as small as possible. Thus, don&#39;t use the energy at eMax, but</span>
<span class="cm">     * but rather of the largest filled energy bin.</span>
<span class="cm">     * This is &#39;largestFilledBin&#39; which is time-dependent and is defined</span>
<span class="cm">     * in the next for-loop.</span>
<span class="cm">     * If an external emax is specified, always choose the highest energy bin</span>
<span class="cm">     * value</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">eMaxConstant</span><span class="p">)</span> <span class="n">largestFilledBin</span> <span class="o">=</span> <span class="n">Esize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">EnergyAxis</span><span class="p">[</span><span class="n">largestFilledBin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">EnergyAxis</span><span class="p">[</span><span class="n">largestFilledBin</span><span class="p">]);</span>
    <span class="n">ebin</span> <span class="o">=</span> <span class="n">e2</span> <span class="o">-</span> <span class="n">e1</span><span class="p">;</span>

    <span class="cm">/* the tbin size is then simply defined as deltaE/Edot_max */</span>
    <span class="n">tbin</span> <span class="o">=</span> <span class="n">ebin</span> <span class="o">/</span> <span class="n">fabs</span><span class="p">(</span><span class="n">EnergyLossRate</span><span class="p">(</span><span class="n">e2</span><span class="p">));</span>

    <span class="cm">/* info writeout */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">T</span> <span class="o">&gt;</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">tt</span> <span class="o">*</span> <span class="p">(</span><span class="n">Age</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">QUIETMODE</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tbin</span> <span class="o">/</span> <span class="p">(</span><span class="n">yr_to_sec</span> <span class="o">*</span> <span class="n">Age</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.e-7</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;                                                              &quot;</span>
                <span class="s">&quot;         </span><span class="se">\r</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">flush</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="mf">100.</span> <span class="o">*</span> <span class="p">(</span><span class="n">T</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Age</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">))</span>
             <span class="o">&lt;&lt;</span> <span class="s">&quot;\% done </span><span class="se">\r</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">flush</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="mf">100.</span> <span class="o">*</span> <span class="p">(</span><span class="n">T</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Age</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">))</span>
             <span class="o">&lt;&lt;</span> <span class="s">&quot;\% done (Energy losses are very high, iteration might take a &quot;</span>
                <span class="s">&quot;while)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">flush</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">tt</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* in case of protons, energy losses are negligible and the computation</span>
<span class="cm">     * is very fast. Thus, there is no reason not to use very fine time bins in</span>
<span class="cm">     * this case.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Type</span><span class="p">)</span> <span class="n">tbin</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">ebin</span> <span class="o">/</span> <span class="n">EnergyLossRate</span><span class="p">(</span><span class="n">e2</span><span class="p">);</span>
    <span class="cm">/* if losses become small (e.g. degrading B-field, or low eMax), time bins</span>
<span class="cm">     * may become very large. This can become problematic if tbin &lt;&lt; Age no</span>
<span class="cm">     * longer</span>
<span class="cm">     * holds. Then, replace tbin by minTimeBin (default: 1yr) if</span>
<span class="cm">     * tbin&gt;minTimeBin.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tbin</span> <span class="o">&gt;</span> <span class="n">minTimeBin</span><span class="p">)</span> <span class="n">tbin</span> <span class="o">=</span> <span class="n">minTimeBin</span><span class="p">;</span>

    <span class="cm">/* negative time steps are not what we want! In this case shout out some</span>
<span class="cm">     * debug. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tbin</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Particles::ComputeGrid: ebin = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ebin</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; (e2,e1) = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">e2</span>
           <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">e1</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;) elossrate(&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">e2</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;) = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">EnergyLossRate</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>
           <span class="o">&lt;&lt;</span> <span class="s">&quot; lastbin = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">largestFilledBin</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* if eMax drops below the lower energy bound of the grid, exit. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">largestFilledBin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

    <span class="cm">/* This is the new time! */</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">T</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">tbin</span> <span class="o">/</span> <span class="n">yr_to_sec</span><span class="p">;</span>
    <span class="cm">/* update the Members at the new time. */</span>
    <span class="n">Lum</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
    <span class="n">SetMembers</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

    <span class="cm">/* iterate over the previous spectrum, stored in Grid[0] and calculate</span>
<span class="cm">     * Grid[1] from it. This is done using a standard, piece-wise linear</span>
<span class="cm">     * advection</span>
<span class="cm">     * scheme. Per default, also a slope limiter is implemented (MinMod method),</span>
<span class="cm">     * that preserves sharp edges in the particle spectrum rather than smearing</span>
<span class="cm">     * it out as in a pure donor-cell algorithm.</span>
<span class="cm">     */</span>

    <span class="cm">/* just for the first step (for speed) */</span>
    <span class="n">ElossRate_e2</span> <span class="o">=</span> <span class="n">EnergyLossRate</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">EnergyAxis</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
    <span class="kt">double</span> <span class="n">particleCount</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Esize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">count</span><span class="o">++</span><span class="p">;</span>
      <span class="n">value</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
      <span class="n">quot</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
      <span class="n">ebin</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>

      <span class="n">e1</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">EnergyAxis</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="n">e2</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">EnergyAxis</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>

      <span class="cm">/* The following block calculates the streaming of particles in an out</span>
<span class="cm">       * of energy bin &#39;i&#39; by cooling. This component of increase / decrease of</span>
<span class="cm">       * particles in bin &#39;i&#39; is caused by particles already present in the</span>
<span class="cm">       * last time step (Grid[0])</span>
<span class="cm">       */</span>
      <span class="n">ebin</span> <span class="o">=</span> <span class="n">e2</span> <span class="o">-</span> <span class="n">e1</span><span class="p">;</span>
      <span class="n">quot</span> <span class="o">=</span> <span class="n">tbin</span> <span class="o">/</span> <span class="n">ebin</span><span class="p">;</span>

      <span class="n">ElossRate_e1</span> <span class="o">=</span> <span class="n">ElossRate_e2</span><span class="p">;</span>
      <span class="n">ElossRate_e2</span> <span class="o">=</span> <span class="n">EnergyLossRate</span><span class="p">(</span><span class="n">e2</span><span class="p">);</span>

      <span class="n">deltaE1</span> <span class="o">=</span> <span class="n">tbin</span> <span class="o">*</span> <span class="n">ElossRate_e1</span><span class="p">;</span>
      <span class="n">deltaE2</span> <span class="o">=</span> <span class="n">tbin</span> <span class="o">*</span> <span class="n">ElossRate_e2</span><span class="p">;</span>
      <span class="cm">/* Donor-cell advection */</span>
      <span class="n">value</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">quot</span> <span class="o">*</span> <span class="n">Grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">ElossRate_e1</span> <span class="o">+</span>
              <span class="n">quot</span> <span class="o">*</span> <span class="n">Grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ElossRate_e2</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span> <span class="n">value</span> <span class="o">+=</span> <span class="n">quot</span> <span class="o">*</span> <span class="n">Grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">ElossRate_e1</span><span class="p">;</span>

      <span class="cm">/* these additional operations result in the superbee algorithm */</span>
      <span class="c1">//      value -=</span>
      <span class="c1">// 0.5*quot*(GetSuperBeeSlope(i,ebin,&amp;Grid)*ElossRate_e1*(ebin-deltaE1)-GetSuperBeeSlope(i+1,ebin,&amp;Grid)*ElossRate_e2*(ebin-deltaE2));</span>
      <span class="cm">/* these additional operations result in the minmod slope limiter</span>
<span class="cm">       * algorithm */</span>
      <span class="n">value</span> <span class="o">-=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">quot</span> <span class="o">*</span> <span class="p">(</span><span class="n">GetMinModSlope</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ebin</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Grid</span><span class="p">)</span> <span class="o">*</span> <span class="n">ElossRate_e1</span> <span class="o">*</span>
                                 <span class="p">(</span><span class="n">ebin</span> <span class="o">-</span> <span class="n">deltaE1</span><span class="p">)</span> <span class="o">-</span>
                             <span class="n">GetMinModSlope</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ebin</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Grid</span><span class="p">)</span> <span class="o">*</span> <span class="n">ElossRate_e2</span> <span class="o">*</span>
                                 <span class="p">(</span><span class="n">ebin</span> <span class="o">-</span> <span class="n">deltaE2</span><span class="p">));</span>

      <span class="n">value</span> <span class="o">*=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">pow</span><span class="p">(</span><span class="n">e1</span> <span class="o">/</span> <span class="n">eMax</span><span class="p">,</span> <span class="n">CutOffFactor</span><span class="p">));</span>

      <span class="cm">/* Increase in particles in bin &#39;i&#39; due to particle injection from the</span>
<span class="cm">       * source */</span>
      <span class="n">value</span> <span class="o">+=</span> <span class="n">tbin</span> <span class="o">*</span> <span class="n">SourceSpectrum</span><span class="p">(</span><span class="n">e1</span><span class="p">);</span>

      <span class="cm">/* Decrease in particles in bin &#39;i&#39; due to particle escape.</span>
<span class="cm">       */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">escapeTime</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">)</span> <span class="n">value</span> <span class="o">-=</span> <span class="n">tbin</span> <span class="o">*</span> <span class="n">Grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">escapeTime</span><span class="p">;</span>

      <span class="cm">/* Determine the largest filled energy bin (needed for the efficient</span>
<span class="cm">       * calculation of the next iterative time bin.</span>
<span class="cm">       */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">)</span> <span class="n">largestFilledBin</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="cm">/* set the particle number (value) in at bin &#39;i&#39; in Grid[i] */</span>
      <span class="n">Grid</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
      <span class="n">particleCount</span> <span class="o">+=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">ebin</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* put a &quot;0&quot; as the last element of this row in order to avoid edge effects.</span>
<span class="cm">     */</span>
    <span class="n">Grid</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">Esize</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
    <span class="cm">/* set the just now calculated spectrum as base spectrum for the next step</span>
<span class="cm">     * This way, only 2 vectors are needed for the calculation of the spectrum</span>
<span class="cm">     */</span>
    <span class="kt">double</span> <span class="n">Econt</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">Grid</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span> <span class="n">Econt</span> <span class="o">+=</span> <span class="n">Grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ii</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">Econt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">)</span> <span class="n">Grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="cm">/* Fill the final lookup, holding the time evolved spectrum at time = Age.</span>
<span class="cm">   * Also, forego edge bins in order to avoid artefacts.</span>
<span class="cm">   */</span>
  <span class="n">Clear2DVector</span><span class="p">(</span><span class="n">ParticleSpectrum</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">EnergyAxis</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">EnergyAxis</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
    <span class="kt">double</span> <span class="n">val</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
    <span class="k">if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">isnan</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">isinf</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">val</span><span class="p">)</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="n">ParticleSpectrum</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="n">ParticleSpectrum</span><span class="p">[</span><span class="n">ParticleSpectrum</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">e1</span><span class="p">);</span>
    <span class="n">ParticleSpectrum</span><span class="p">[</span><span class="n">ParticleSpectrum</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/* Important for wrapper function &#39;ComputeGridInTimeInterval&#39;: remove the last</span>
<span class="cm">   * vector (Grid[1]) so that Grid has the same shape as in the beginning of</span>
<span class="cm">   * this function.</span>
<span class="cm">   */</span>
  <span class="n">Grid</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>

  <span class="cm">/* for the format of the info writeout */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">QUIETMODE</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    -&gt; DONE!   &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** slope for MinMod slope limiter method */</span>
<span class="kt">double</span> <span class="n">Particles</span><span class="o">::</span><span class="n">GetMinModSlope</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">double</span> <span class="n">deltaX</span><span class="p">,</span>
                                 <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">Grid</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="p">((</span><span class="o">*</span><span class="n">Grid</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="o">*</span><span class="n">Grid</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">deltaX</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">b</span> <span class="o">=</span> <span class="p">((</span><span class="o">*</span><span class="n">Grid</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="o">*</span><span class="n">Grid</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">deltaX</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">MinMod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">sigma</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** slope for superbee slope limiter method */</span>
<span class="kt">double</span> <span class="n">Particles</span><span class="o">::</span><span class="n">GetSuperBeeSlope</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">double</span> <span class="n">deltaX</span><span class="p">,</span>
                                   <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">Grid</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="p">((</span><span class="o">*</span><span class="n">Grid</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="o">*</span><span class="n">Grid</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">deltaX</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">b</span> <span class="o">=</span> <span class="p">((</span><span class="o">*</span><span class="n">Grid</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="o">*</span><span class="n">Grid</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">deltaX</span><span class="p">;</span>

  <span class="kt">double</span> <span class="n">sigma1</span> <span class="o">=</span> <span class="n">MinMod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">b</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">sigma2</span> <span class="o">=</span> <span class="n">MinMod</span><span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

  <span class="kt">double</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">MaxMod</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">sigma</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** MaxMod function for slope limiters */</span>
<span class="kt">double</span> <span class="n">Particles</span><span class="o">::</span><span class="n">MaxMod</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mf">0.</span> <span class="o">&amp;&amp;</span> <span class="n">fabs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">fabs</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mf">0.</span> <span class="o">&amp;&amp;</span> <span class="n">fabs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="mf">0.</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** MinMod function for slope limiters */</span>
<span class="kt">double</span> <span class="n">Particles</span><span class="o">::</span><span class="n">MinMod</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mf">0.</span> <span class="o">&amp;&amp;</span> <span class="n">fabs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">fabs</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mf">0.</span> <span class="o">&amp;&amp;</span> <span class="n">fabs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="mf">0.</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** wrapper function to calculate the grid only in a specified time interval dT</span>
<span class="cm"> * = T2-T2</span>
<span class="cm"> * This is especially useful for the creation of time-series of spectra and</span>
<span class="cm"> * necessary</span>
<span class="cm"> * as the &#39;ComputeGrid&#39; function only stores two spectra (the actual one and</span>
<span class="cm"> * that in the</span>
<span class="cm"> * time step before) due to memory storage reasons.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">ComputeGridInTimeInterval</span><span class="p">(</span><span class="kt">double</span> <span class="n">T1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">T2</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">T1</span> <span class="o">&lt;=</span> <span class="n">Tmin</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Particles::ComputeGridInTimeInterval T1&lt;internal min time (&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">T1</span>
         <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Tmin</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;). set it artificially to &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Tmin</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;yrs.&quot;</span>
         <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">T1</span> <span class="o">=</span> <span class="n">Tmin</span> <span class="o">*</span> <span class="mf">1.001</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Clear2DVector</span><span class="p">(</span><span class="n">ParticleSpectrum</span><span class="p">);</span>
  <span class="n">ComputeGrid</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">energyAxis</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">timeAxis</span><span class="p">,</span> <span class="n">yr_to_sec</span> <span class="o">*</span> <span class="p">(</span><span class="n">T2</span> <span class="o">-</span> <span class="n">T1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">CalcSpecSemiAnalyticNoELoss</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Tmin</span> <span class="o">&gt;=</span> <span class="n">Age</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;CalcSpecSemiAnalyticNoELoss: Tmin is larger/equal &quot;</span>
            <span class="s">&quot;than source age... Exiting&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Clear2DVector</span><span class="p">(</span><span class="n">ParticleSpectrum</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">totallum</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">LumConstant</span><span class="p">)</span>
    <span class="n">totallum</span> <span class="o">=</span> <span class="n">LumConstant</span><span class="o">*</span><span class="n">Age</span><span class="p">;</span>
  <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">LumVector</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">gsl_interp_accel_reset</span><span class="p">(</span><span class="n">accLum</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">gsl_spline_eval_integ_e</span><span class="p">(</span><span class="n">LumLookup</span><span class="p">,</span> <span class="n">Tmin</span><span class="p">,</span> <span class="n">Age</span><span class="p">,</span> <span class="n">accLum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">totallum</span><span class="p">))</span>
      <span class="n">totallum</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">return</span><span class="p">;</span>
  <span class="n">LumConstant</span> <span class="o">=</span> <span class="n">totallum</span><span class="o">*</span><span class="n">yr_to_sec</span><span class="p">;</span>
  <span class="n">SetMembers</span><span class="p">(</span><span class="n">Age</span><span class="p">);</span>

  <span class="kt">double</span> <span class="n">logstep</span> <span class="o">=</span> <span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">eMax</span><span class="p">)</span> <span class="o">-</span> <span class="n">log10</span><span class="p">(</span><span class="n">Emin</span><span class="p">))</span> <span class="o">/</span> <span class="n">ebins</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">double</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Emin</span><span class="p">;</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">eMax</span><span class="p">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">log10</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="n">logstep</span><span class="p">))</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">val</span> <span class="o">=</span> <span class="n">SourceSpectrum</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">isnan</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">isinf</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">val</span><span class="p">)</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="n">ParticleSpectrum</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="n">ParticleSpectrum</span><span class="p">[</span><span class="n">ParticleSpectrum</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
    <span class="n">ParticleSpectrum</span><span class="p">[</span><span class="n">ParticleSpectrum</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">CalcSpecSemiAnalyticConstELoss</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Tmin</span> <span class="o">&gt;=</span> <span class="n">Age</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Particles::CalcSpecSemiAnalyticConstELoss: Tmin is larger/equal &quot;</span>
            <span class="s">&quot;than source age... Exiting&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">fPointer</span> <span class="n">IntFunc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">Clear2DVector</span><span class="p">(</span><span class="n">ParticleSpectrum</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">logstep</span> <span class="o">=</span> <span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">eMax</span><span class="p">)</span> <span class="o">-</span> <span class="n">log10</span><span class="p">(</span><span class="n">Emin</span><span class="p">))</span> <span class="o">/</span> <span class="n">ebins</span><span class="p">;</span>

  <span class="cm">/* info writeout. Disable it by using &#39;ToggleQuietMode()&#39; */</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Type</span> <span class="o">&amp;&amp;</span> <span class="n">QUIETMODE</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;** Evolving Electron Spectrum:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Type</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">QUIETMODE</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;** Evolving Proton Spectrum:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">// steady state solution</span>
  <span class="kt">double</span> <span class="n">maxCoolingTime</span> <span class="o">=</span> <span class="o">-</span><span class="mf">100.</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">double</span> <span class="n">E</span> <span class="o">=</span> <span class="n">Emin</span><span class="p">;</span> <span class="n">E</span> <span class="o">&lt;</span> <span class="n">eMax</span><span class="p">;</span> <span class="n">E</span> <span class="o">*=</span> <span class="mf">1.01</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">CoolingTime</span> <span class="o">=</span> <span class="n">E</span> <span class="o">/</span> <span class="n">EnergyLossRate</span><span class="p">(</span><span class="n">E</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CoolingTime</span> <span class="o">&gt;</span> <span class="n">maxCoolingTime</span><span class="p">)</span> <span class="n">maxCoolingTime</span> <span class="o">=</span> <span class="n">CoolingTime</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">maxCoolingTime</span> <span class="o">/=</span> <span class="n">yr_to_sec</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Age</span> <span class="o">&gt;</span> <span class="n">maxCoolingTime</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">dummy</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
    <span class="n">IntFunc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Particles</span><span class="o">::</span><span class="n">SourceSpectrumWrapper</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">tt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">SetMembers</span><span class="p">(</span><span class="n">Age</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">double</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Emin</span><span class="p">;</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">eMax</span><span class="p">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">log10</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="n">logstep</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">QUIETMODE</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">tt</span> <span class="o">/</span> <span class="n">ebins</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;\% done</span><span class="se">\r</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">flush</span><span class="p">;</span>
      <span class="kt">double</span> <span class="n">val</span> <span class="o">=</span> <span class="n">Integrate</span><span class="p">(</span><span class="n">IntFunc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">eMax</span><span class="p">,</span> <span class="n">integratorTolerance</span><span class="p">)</span> <span class="o">/</span>
                   <span class="n">EnergyLossRate</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">isnan</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">isinf</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">val</span><span class="p">)</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="n">ParticleSpectrum</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">());</span>
      <span class="n">ParticleSpectrum</span><span class="p">[</span><span class="n">ParticleSpectrum</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
      <span class="n">ParticleSpectrum</span><span class="p">[</span><span class="n">ParticleSpectrum</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
      <span class="n">tt</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// time integration (constant energy losses)</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">Tmin</span> <span class="o">=</span> <span class="n">vETrajectory</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">IntFunc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Particles</span><span class="o">::</span><span class="n">SemiAnalyticConstELossIntegrand</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">tt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">double</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Emin</span><span class="p">;</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">eMax</span><span class="p">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">log10</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="n">logstep</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">QUIETMODE</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">tt</span> <span class="o">/</span> <span class="n">ebins</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;\% done</span><span class="se">\r</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">flush</span><span class="p">;</span>
      <span class="kt">double</span> <span class="n">val</span> <span class="o">=</span> <span class="n">Integrate</span><span class="p">(</span><span class="n">IntFunc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">,</span> <span class="n">log10</span><span class="p">(</span><span class="n">Tmin</span><span class="p">),</span> <span class="n">log10</span><span class="p">(</span><span class="n">Age</span><span class="p">),</span> <span class="mf">5.e-3</span><span class="p">);</span>
      <span class="n">SetMembers</span><span class="p">(</span><span class="n">Age</span><span class="p">);</span>
      <span class="n">val</span> <span class="o">/=</span> <span class="n">EnergyLossRate</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">isnan</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">isinf</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">val</span><span class="p">)</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="n">ParticleSpectrum</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">());</span>
      <span class="n">ParticleSpectrum</span><span class="p">[</span><span class="n">ParticleSpectrum</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
      <span class="n">ParticleSpectrum</span><span class="p">[</span><span class="n">ParticleSpectrum</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
      <span class="n">tt</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">double</span> <span class="n">Particles</span><span class="o">::</span><span class="n">SemiAnalyticConstELossIntegrand</span><span class="p">(</span><span class="kt">double</span> <span class="n">T</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">par</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">tdash</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">Enow</span><span class="p">;</span>
  <span class="n">Enow</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span><span class="n">par</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">gsl_spline_eval_e</span><span class="p">(</span><span class="n">energyTrajectoryInverse</span><span class="p">,</span> <span class="n">log10</span><span class="p">(</span><span class="n">Enow</span><span class="p">),</span> <span class="n">accTrInv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tdash</span><span class="p">))</span>
    <span class="k">return</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">T</span> <span class="o">&gt;</span> <span class="n">tdash</span><span class="p">)</span> <span class="k">return</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="n">T</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">Age</span> <span class="o">-</span> <span class="n">T</span> <span class="o">&lt;</span> <span class="n">Tmin</span><span class="p">)</span> <span class="k">return</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="n">tdash</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">tdash</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">gsl_spline_eval_e</span><span class="p">(</span><span class="n">energyTrajectory</span><span class="p">,</span> <span class="n">log10</span><span class="p">(</span><span class="n">tdash</span> <span class="o">-</span> <span class="n">T</span><span class="p">),</span> <span class="n">accTr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">E</span><span class="p">))</span>
    <span class="k">return</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="n">E</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">E</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">E</span> <span class="o">&gt;</span> <span class="n">eMax</span> <span class="o">||</span> <span class="n">E</span> <span class="o">&lt;=</span> <span class="mf">0.</span><span class="p">)</span> <span class="k">return</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="n">SetMembers</span><span class="p">(</span><span class="n">Age</span> <span class="o">-</span> <span class="n">T</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SACELI_Told</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SACELI_Told</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
    <span class="k">return</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">double</span> <span class="n">dT</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">-</span> <span class="n">SACELI_Told</span><span class="p">)</span> <span class="o">*</span> <span class="n">yr_to_sec</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">dlogT</span> <span class="o">=</span> <span class="n">log10</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">-</span> <span class="n">log10</span><span class="p">(</span><span class="n">SACELI_Told</span><span class="p">);</span>
  <span class="n">SACELI_Told</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">EnergyLossRate</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">*</span> <span class="n">SourceSpectrum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">*</span> <span class="n">dT</span> <span class="o">/</span> <span class="n">dlogT</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">SetType</span><span class="p">(</span><span class="n">string</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="s">&quot;electrons&quot;</span><span class="p">))</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="s">&quot;protons&quot;</span><span class="p">))</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Particles::SetType: What the f***! Specify supported particle &quot;</span>
            <span class="s">&quot;species! &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="n">Particles</span><span class="o">::</span><span class="n">SourceSpectrumWrapper</span><span class="p">(</span><span class="kt">double</span> <span class="n">E</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">par</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">SourceSpectrum</span><span class="p">(</span><span class="n">E</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Determine the common time boundaries of the provided lookups for the</span>
<span class="cm"> * evolution of parameters (Source Luminosity,B-Field, Ambient density etc.).</span>
<span class="cm"> * If everything is set to constant values, i.e. in a stationary scenario,</span>
<span class="cm"> * these boundaries will be set to {TminInternal,TmaxInternal} = {1.e-10,1.e100}yrs.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">DetermineLookupTimeBoundaries</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// determine starting time and energy</span>
  <span class="kt">double</span> <span class="n">lumtmin</span><span class="p">,</span> <span class="n">emaxtmin</span><span class="p">,</span> <span class="n">ntmin</span><span class="p">,</span> <span class="n">btmin</span><span class="p">,</span> <span class="n">rtmin</span><span class="p">,</span> <span class="n">vtmin</span><span class="p">,</span> <span class="n">esctmin</span><span class="p">,</span> <span class="n">lumtmax</span><span class="p">,</span>
      <span class="n">emaxtmax</span><span class="p">,</span> <span class="n">ntmax</span><span class="p">,</span> <span class="n">btmax</span><span class="p">,</span> <span class="n">rtmax</span><span class="p">,</span> <span class="n">vtmax</span><span class="p">,</span> <span class="n">esctmax</span><span class="p">;</span>
  <span class="n">lumtmin</span> <span class="o">=</span> <span class="n">emaxtmin</span> <span class="o">=</span> <span class="n">ntmin</span> <span class="o">=</span> <span class="n">btmin</span> <span class="o">=</span> <span class="n">rtmin</span> <span class="o">=</span> <span class="n">vtmin</span> <span class="o">=</span> <span class="n">esctmin</span> <span class="o">=</span> <span class="mf">1.e-10</span><span class="p">;</span>
  <span class="n">lumtmax</span> <span class="o">=</span> <span class="n">emaxtmax</span> <span class="o">=</span> <span class="n">ntmax</span> <span class="o">=</span> <span class="n">btmax</span> <span class="o">=</span> <span class="n">rtmax</span> <span class="o">=</span> <span class="n">vtmax</span> <span class="o">=</span> <span class="n">esctmax</span> <span class="o">=</span> <span class="mf">1.e100</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">LumVector</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">lumtmin</span> <span class="o">=</span> <span class="n">LumVector</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">eMaxVector</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">emaxtmin</span> <span class="o">=</span> <span class="n">eMaxVector</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">NVector</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">ntmin</span> <span class="o">=</span> <span class="n">NVector</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">BVector</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">btmin</span> <span class="o">=</span> <span class="n">BVector</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">RVector</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">rtmin</span> <span class="o">=</span> <span class="n">RVector</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">VVector</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">vtmin</span> <span class="o">=</span> <span class="n">VVector</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">EscapeVector</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">esctmin</span> <span class="o">=</span> <span class="n">EscapeVector</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">LumVector</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">lumtmax</span> <span class="o">=</span> <span class="n">LumVector</span><span class="p">[</span><span class="n">LumVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">eMaxVector</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">emaxtmax</span> <span class="o">=</span> <span class="n">eMaxVector</span><span class="p">[</span><span class="n">eMaxVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">NVector</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">ntmax</span> <span class="o">=</span> <span class="n">NVector</span><span class="p">[</span><span class="n">NVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">BVector</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">btmax</span> <span class="o">=</span> <span class="n">BVector</span><span class="p">[</span><span class="n">BVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">RVector</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">rtmax</span> <span class="o">=</span> <span class="n">RVector</span><span class="p">[</span><span class="n">RVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">VVector</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">vtmax</span> <span class="o">=</span> <span class="n">VVector</span><span class="p">[</span><span class="n">VVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">EscapeVector</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">esctmin</span> <span class="o">=</span> <span class="n">EscapeVector</span><span class="p">[</span><span class="n">EscapeVector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>

  <span class="kt">double</span> <span class="n">T0</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">T3</span><span class="p">,</span> <span class="n">T4</span><span class="p">,</span> <span class="n">T</span><span class="p">;</span>

  <span class="c1">// first determine highest common lower boundary time of the lookups</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">emaxtmin</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ntmin</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">btmin</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rtmin</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vtmin</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">TminInternal</span><span class="p">;</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">rtmin</span> <span class="o">&gt;</span> <span class="n">vtmin</span><span class="p">)</span> <span class="o">?</span> <span class="n">T0</span> <span class="o">=</span> <span class="nl">rtmin</span> <span class="p">:</span> <span class="n">T0</span> <span class="o">=</span> <span class="n">vtmin</span><span class="p">;</span>
    <span class="p">(</span><span class="n">ntmin</span> <span class="o">&gt;</span> <span class="n">T0</span><span class="p">)</span> <span class="o">?</span> <span class="n">T1</span> <span class="o">=</span> <span class="nl">ntmin</span> <span class="p">:</span> <span class="n">T1</span> <span class="o">=</span> <span class="n">T0</span><span class="p">;</span>
    <span class="p">(</span><span class="n">btmin</span> <span class="o">&gt;</span> <span class="n">T1</span><span class="p">)</span> <span class="o">?</span> <span class="n">T2</span> <span class="o">=</span> <span class="nl">btmin</span> <span class="p">:</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">T1</span><span class="p">;</span>
    <span class="p">(</span><span class="n">esctmin</span> <span class="o">&gt;</span> <span class="n">T2</span><span class="p">)</span> <span class="o">?</span> <span class="n">T3</span> <span class="o">=</span> <span class="nl">esctmin</span> <span class="p">:</span> <span class="n">T3</span> <span class="o">=</span> <span class="n">T2</span><span class="p">;</span>
    <span class="p">(</span><span class="n">lumtmin</span> <span class="o">&gt;</span> <span class="n">T3</span><span class="p">)</span> <span class="o">?</span> <span class="n">T4</span> <span class="o">=</span> <span class="nl">lumtmin</span> <span class="p">:</span> <span class="n">T4</span> <span class="o">=</span> <span class="n">T3</span><span class="p">;</span>
    <span class="p">(</span><span class="n">emaxtmin</span> <span class="o">&gt;</span> <span class="n">T4</span><span class="p">)</span> <span class="o">?</span> <span class="n">T</span> <span class="o">=</span> <span class="nl">emaxtmin</span> <span class="p">:</span> <span class="n">T</span> <span class="o">=</span> <span class="n">T4</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">TminInternal</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>

  <span class="c1">// now do the similar thing to get the lowest common higher lookup boundary</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">emaxtmin</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ntmin</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">btmin</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rtmin</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vtmin</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">TmaxInternal</span><span class="p">;</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">rtmax</span> <span class="o">&lt;</span> <span class="n">vtmax</span><span class="p">)</span> <span class="o">?</span> <span class="n">T0</span> <span class="o">=</span> <span class="nl">rtmax</span> <span class="p">:</span> <span class="n">T0</span> <span class="o">=</span> <span class="n">vtmax</span><span class="p">;</span>
    <span class="p">(</span><span class="n">ntmax</span> <span class="o">&lt;</span> <span class="n">T0</span><span class="p">)</span> <span class="o">?</span> <span class="n">T1</span> <span class="o">=</span> <span class="nl">ntmax</span> <span class="p">:</span> <span class="n">T1</span> <span class="o">=</span> <span class="n">T0</span><span class="p">;</span>
    <span class="p">(</span><span class="n">btmax</span> <span class="o">&lt;</span> <span class="n">T1</span><span class="p">)</span> <span class="o">?</span> <span class="n">T2</span> <span class="o">=</span> <span class="nl">btmax</span> <span class="p">:</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">T1</span><span class="p">;</span>
    <span class="p">(</span><span class="n">esctmax</span> <span class="o">&lt;</span> <span class="n">T2</span><span class="p">)</span> <span class="o">?</span> <span class="n">T3</span> <span class="o">=</span> <span class="nl">esctmax</span> <span class="p">:</span> <span class="n">T3</span> <span class="o">=</span> <span class="n">T2</span><span class="p">;</span>
    <span class="p">(</span><span class="n">lumtmax</span> <span class="o">&lt;</span> <span class="n">T3</span><span class="p">)</span> <span class="o">?</span> <span class="n">T4</span> <span class="o">=</span> <span class="nl">lumtmax</span> <span class="p">:</span> <span class="n">T4</span> <span class="o">=</span> <span class="n">T3</span><span class="p">;</span>
    <span class="p">(</span><span class="n">emaxtmax</span> <span class="o">&lt;</span> <span class="n">T4</span><span class="p">)</span> <span class="o">?</span> <span class="n">T</span> <span class="o">=</span> <span class="nl">emaxtmax</span> <span class="p">:</span> <span class="n">T</span> <span class="o">=</span> <span class="n">T4</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">TmaxInternal</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">CalculateEnergyTrajectory</span><span class="p">(</span><span class="kt">double</span> <span class="n">TExt</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">TminInternal</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Particles::CalculateEnergyTrajectory: Calculate internal Tmin &quot;</span>
            <span class="s">&quot;first by running DetermineLookupStartingTime(). Exiting.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Clear2DVector</span><span class="p">(</span><span class="n">vETrajectory</span><span class="p">);</span>

  <span class="kt">double</span> <span class="n">T</span> <span class="o">=</span> <span class="n">TminInternal</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">E</span><span class="p">,</span> <span class="n">Edot</span><span class="p">,</span> <span class="n">dt</span><span class="p">;</span>
  <span class="n">vETrajectory</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">TExt</span><span class="p">)</span> <span class="p">(</span><span class="n">TExt</span> <span class="o">&gt;</span> <span class="n">T</span><span class="p">)</span> <span class="o">?</span> <span class="n">T</span> <span class="o">=</span> <span class="nl">TExt</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">T</span> <span class="o">*=</span> <span class="mf">1.1</span><span class="p">;</span>
  <span class="n">SetMembers</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
  <span class="n">E</span> <span class="o">=</span> <span class="n">eMax</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">E</span> <span class="o">&gt;=</span> <span class="n">Emin</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vETrajectory</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="n">vETrajectory</span><span class="p">[</span><span class="n">vETrajectory</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
    <span class="n">vETrajectory</span><span class="p">[</span><span class="n">vETrajectory</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">E</span><span class="p">);</span>
    <span class="n">Edot</span> <span class="o">=</span> <span class="n">EnergyLossRate</span><span class="p">(</span><span class="n">E</span><span class="p">);</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mf">2.e-2</span> <span class="o">*</span> <span class="n">E</span> <span class="o">/</span> <span class="n">Edot</span><span class="p">;</span>
    <span class="n">E</span> <span class="o">-=</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">Edot</span><span class="p">;</span>
    <span class="n">T</span> <span class="o">+=</span> <span class="n">dt</span> <span class="o">/</span> <span class="n">yr_to_sec</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">&gt;</span><span class="n">TmaxInternal</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">SetMembers</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">vETrajectory</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="kt">double</span> <span class="n">x1</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="n">y1</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="n">y2</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">xVal</span> <span class="o">=</span> <span class="n">log10</span><span class="p">(</span><span class="n">vETrajectory</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
    <span class="kt">double</span> <span class="n">eVal</span> <span class="o">=</span> <span class="n">log10</span><span class="p">(</span><span class="n">vETrajectory</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">isinf</span><span class="p">(</span><span class="n">xVal</span><span class="p">)</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">isinf</span><span class="p">(</span><span class="n">eVal</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">isnan</span><span class="p">(</span><span class="n">xVal</span><span class="p">)</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">isnan</span><span class="p">(</span><span class="n">eVal</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">isnan</span><span class="p">(</span><span class="n">xVal</span><span class="p">)</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">isnan</span><span class="p">(</span><span class="n">eVal</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
    <span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">xVal</span><span class="p">;</span>
    <span class="n">y1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eVal</span><span class="p">;</span>
    <span class="n">x2</span><span class="p">[</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eVal</span><span class="p">;</span>
    <span class="n">y2</span><span class="p">[</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">xVal</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">energyTrajectory</span> <span class="o">=</span> <span class="n">gsl_spline_alloc</span><span class="p">(</span><span class="n">gsl_interp_linear</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="n">gsl_spline_init</span><span class="p">(</span><span class="n">energyTrajectory</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="n">energyTrajectoryInverse</span> <span class="o">=</span> <span class="n">gsl_spline_alloc</span><span class="p">(</span><span class="n">gsl_interp_linear</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="n">gsl_spline_init</span><span class="p">(</span><span class="n">energyTrajectoryInverse</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Return a particle SED dN/dE vs E (erg vs TeV)</span>
<span class="cm"> */</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Particles</span><span class="o">::</span><span class="n">GetParticleSED</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ParticleSpectrum</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">E</span> <span class="o">=</span> <span class="n">ParticleSpectrum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="kt">double</span> <span class="n">ETeV</span> <span class="o">=</span> <span class="n">E</span> <span class="o">/</span> <span class="n">TeV_to_erg</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">N</span> <span class="o">=</span> <span class="n">ParticleSpectrum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">N</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="n">v</span><span class="p">[</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">ETeV</span><span class="p">);</span>
    <span class="n">v</span><span class="p">[</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">E</span> <span class="o">*</span> <span class="n">E</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">Clear2DVector</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
  <span class="n">v</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Particles</span><span class="o">::</span><span class="n">SetIntegratorMemory</span><span class="p">(</span><span class="n">string</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">mode</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="s">&quot;light&quot;</span><span class="p">))</span> <span class="n">gslmemory</span><span class="o">=</span><span class="mi">1000</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">mode</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="s">&quot;normal&quot;</span><span class="p">))</span> <span class="n">gslmemory</span><span class="o">=</span><span class="mi">5000</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">mode</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="s">&quot;heavy&quot;</span><span class="p">))</span> <span class="n">gslmemory</span><span class="o">=</span><span class="mi">10000</span><span class="p">;</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Particle::SetIntegratorMemory: Set valid mode. Possibilities: &quot;</span>
               <span class="s">&quot;  light - normal - heavy. Default is &#39;normal&#39;. &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * Integration function using the GSL QAG functionality</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">double</span> <span class="n">Particles</span><span class="o">::</span><span class="n">Integrate</span><span class="p">(</span><span class="n">fPointer</span> <span class="n">f</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">emin</span><span class="p">,</span> <span class="kt">double</span> <span class="n">emax</span><span class="p">,</span>
                            <span class="kt">double</span> <span class="n">tolerance</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">integral</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>
  <span class="cm">/* no comment */</span>
  <span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">double</span> <span class="n">xx</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">double</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;*</span><span class="n">f</span><span class="p">)(</span><span class="n">xx</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="p">);</span>
  <span class="p">};</span>
  <span class="n">GSLfuncPart</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">Fp</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
  <span class="n">gsl_function</span> <span class="n">F</span> <span class="o">=</span> <span class="o">*</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">gsl_function</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Fp</span><span class="p">);</span>
  <span class="n">gsl_integration_workspace</span> <span class="o">*</span><span class="n">w</span> <span class="o">=</span> <span class="n">gsl_integration_workspace_alloc</span><span class="p">(</span><span class="n">gslmemory</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">gsl_integration_qag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">F</span><span class="p">,</span> <span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">gslmemory</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">integral</span><span class="p">,</span>
                          <span class="o">&amp;</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">gsl_integration_workspace_free</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
    <span class="k">return</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">gsl_integration_workspace_free</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">integral</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="particles_header.html" class="btn btn-neutral float-right" title="Particles: header" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="particles_members.html" class="btn btn-neutral" title="Particles: public members" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Joachim Hahn.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.9',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>